import java.lang.reflect.Type

apply plugin: 'com.android.application'
apply from: 'version.gradle'

android {//配置了所有android构建过程需要的参数，这里也是android DSL的入口点
    /**
     * 默认情况下，只需要配置目标编译SDK版本和编译工具版本，即compileSdkVersion和buildToolsVersion属性
     */
    compileSdkVersion 28 //相当于旧构建系统中project.properites文件中的target属性。这个新的属性可以跟
    // 旧的target属性一样指定一个int或者String类型的值
    // 只能添加android plugin。同时添加java plugin会导致构建错误
    //需要在相同路径下添加一个local.properties文件，并使用sdk.dir属性来设置SDK路径
    //也可以通过设置ANDROID_HOME环境变量，这两种方式没有什么不同

    /**
     * android tasks
     * android plugin使用相同的约定以兼容其他插件，并附加了自己的标识性task，包括：
     *      assemble：这个task用于组合项目中的所有输出
     *      check：这个task用于执行所有检查
     *      connectedCheck：这个task将会在一个指定的设备或者模拟器上执行检查，他们可以同时在所有连接的设备上执行
     *      deviceCheck：通过APIs连接远程设备来执行检查，这是在CL服务器上使用的
     *      build：这个task执行assmble和check的所有工作
     *      clean：这个task清空项目的所有输出
     * 这些新的标示性task是必须的，以保证能够在没有设备连接的情况下执行定期检查
     * 注意：build task不依赖于deviceCheck或者connectedCheck
     */
    /**
     * assmble:
     *      assembleDebug
     *      assembleRelease
     * 注意：gradle在命令行终端上支持驼峰命名法的task简称，例如：执行gradle aR命令等同于执行gradle assembleRelease
     */


    defaultConfig {//默认配置，它是一个ProductFlavor。ProductFlavor允许我们根据不同的情况同事生成多个不同的apk包
        applicationId "com.example.grdledemo" //包名，可以跟AndroidManifest里面的package不同，他们之间并没有直接的关系。
        //package指的是代码目录下路径，applicationId指的是app对外发布的唯一标识，
        // 会在签名，申请第三方库，发布的时候用到
        minSdkVersion 21 //最小兼容版本
        targetSdkVersion 28 //基于哪个android版本开发
        versionCode 1 //版本号，在使用bugly自动升级能不能收到升级推送就是基于这个
        versionName "1.0" //版本名称，用户可以查看
        multiDexEnabled true//配置该BuildType是否自动拆分多个Dex的功能。655535方法限制
        flavorDimensions "applicationId" //多渠道打包的时候，保证所有的flavor都属于同一个维度，Gradle3.0之后必须定义
                                            //这样就可以在不同的包中形成不同的applicationId和versionName
        ndk {
            //设置支持的SO库架构
            abiFilters 'armeabi', 'x86', 'armabi-v7a', 'x86_64'
        }

        /**
         * 配置项目结构
         */
        sourceSets {
            main {
//                manifest.srcFile 'AndroidManifest.xml'
//                java.srcDirs = ['src']
//
//                resources.srcDirs = ['src']
//                aidl.srcDirs = ['src']
//
//                renderscript.srcDirs = ['src']
//
//                res.srcDirs = ['res']
//                assets.srcDirs = ['assets']
                jniLibs.srcDirs = ['libs']
            }
//            androidTest.setRoot('tests')
        }

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {//构建类型，在android gradle工程中，已经内置了debug和release两个构建类型
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

//            name//build Type的名字
//            applicationIdSuffix//应用id后缀
//            versionNameSuffix//版本名称后缀
//            debuggable//是否生成一个debug的apk
//            minifyEnable//是否混淆
//            proguardFiles//混淆文件
//            signingConfig//签名配置
//            manifestPlaceholders//清单占位符
//            shrinkResources//是否去除未利用的资源，默认false，不去除
//            zipAlignEnable//是否使用zipalign工具压缩
//            multiDexEnabled//是否拆成多个Dex
//            multiDexKeepFile//指定文本文件编译进主Dex文件中
//            multiDexKeepProguard//指定混淆文件编译进主Dex文件中


        }
    }

    signingConfigs {//签名配置
        // 默认情况下，debug模式的签名已经被配置好了，一般位于$HOME/.android/debug.keystore，一般不需要单独配置debug的签名信息
        debug {
//            storeFile file('')//签名文件
//            storePassword ""//签名证书文件密码
//            keyAlias ""//签名证书中秘钥别名
//            keyPassword ""//签名证书中秘钥的密码
        }
        release {
//            storeFile file('')
//            storePassword ""
//            keyAlias ""
//            keyPassword ""
//            //自定义输出配置
//            android.applicationVariants.all{variant->
//                variant.outputs.all{
//                    outputFileName=".apk"
//                }
//            }
        }
    }

    productFlavors {//Gradle多渠道打包，可以在不同的包定义不同的变量，实现自己的定制化版本的需求
        //可以在android studio的Build Variants上选择编译不同的版本
        GZ_test {
            "applicationId" ''
            "versionName" "0.7.58"
            manifestPlaceholders = [APP_NAME: "ceshi"]//占位符，可以通过它动态配置AndroidManifest文件一些内容，比如app的名字
            //buildConfigField定义的变量会在build/generated/source/buildConfig里面生成对应的BuildConfig文件，
            //在代码里可直接调用来判断当前所属渠道
            buildConfigField "String", "BASE_URL", "\"aaaaaa\""
            buildConfigField "String", "VERSION", "\"GZ\""
            buildConfigField "boolean", "isTest", "true"
        }
        GZ_verification {
            "applicationId" ''
            "versionName" "1.7.58"
            manifestPlaceholders = [APP_NAME: "yanzheng"]
            buildConfigField "String", "BASE_URL", "\"bbbbb\""
            buildConfigField "String", "VERSION", "\"GD\""
            buildConfigField "boolean", "isTest", "false"
        }
    }

    testOptions{
        dexOptions{//java源码被编译成class字节码之后，在打包成apk的时候被dx命令优化成Android虚拟机可执行的DEX文件
//            incremental true    //DSL element 'DexOptions.incremental' is obsolete and will be removed at the end of 2018.
                                //这个方法2018年被弃用
            javaMaxHeapSize "4g"//内存设置，默认为1G，
                                // 当内存不足的时候，会提示java,lang.OutOfMemoryError: GC overhead limit exceeded
        }
    }
}

dependencies {
    //Gradle3.0之后把compile改成了implementation和api
    //implementation仅限于本module使用，api跟之前compile一样，在别的module也可以调用
    implementation fileTree(dir: 'libs', include: ['*.jar'])//依赖本地libs文件夹下的扩展名为jar的文件
    implementation "com.android.support:appcompat-v7:${versionName}"
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
